
```python
class Solution:
    def dfs_recursive(self, graph, u, visited):
        print(u)                        # 访问节点
        visited.add(u)                  # 节点 u 标记其已访问

        for v in graph[u]:
            if v not in visited:        # 节点 v 未访问过
                # 深度优先搜索遍历节点
                self.dfs_recursive(graph, v, visited)
        

graph = {
    "A": ["B", "C"],
    "B": ["A", "C", "D"],
    "C": ["A", "B", "D", "E"],
    "D": ["B", "C", "E", "F"],
    "E": ["C", "D"],
    "F": ["D", "G"],
    "G": []
}

# 基于递归实现的深度优先搜索
visited = set()
Solution().dfs_recursive(graph, "A", visited)

```

在 LeetCode 做题时，**DFS（深度优先搜索）** 和 **BFS（广度优先搜索）** 是两种非常常见且强大的遍历思想。  
什么时候用哪个，取决于 **题目的特点、目标** 以及 **对性能的要求**。  
我给你总结一下，方便实战参考：

---

## ✅ 一、优先考虑用 DFS 的场景：
### 📌 **1. 需要遍历“所有路径”、“所有组合”**
- 经典场景：回溯（Backtracking）
- 如：排列、组合、子集、二叉树路径、迷宫所有路径
- 示例题：
  - `LeetCode 46. 全排列`
  - `LeetCode 78. 子集`
  - `LeetCode 131. 分割回文串`

### 📌 **2. 结构是“树”或“递归”天然适合**
- 如二叉树遍历、N叉树遍历
- 示例题：
  - `LeetCode 104. 二叉树的最大深度`
  - `LeetCode 98. 验证二叉搜索树`

### 📌 **3. 需要递归深入探索或碰到"岛屿问题"**
- 如：连通块问题、区域染色问题
- 示例题：
  - `LeetCode 200. 岛屿数量`
  - `LeetCode 695. 岛屿的最大面积`

### 📌 **4. 空间（queue）受限，递归可接受**
- 递归栈空间可控时，DFS比BFS更省事

---

## ✅ 二、优先考虑用 BFS 的场景：
### 📌 **1. 需要求“最短路径”、“最小步数”**
- BFS 层层推进，最先到达目标的路径就是最短的
- 示例题：
  - `LeetCode 127. 单词接龙`
  - `LeetCode 752. 打开转盘锁`
  - `LeetCode 279. 完全平方数`

### 📌 **2. 多源同时扩散的题目（如火烧、感染）**
- BFS天然适合模拟“同时蔓延”的过程
- 示例题：
  - `LeetCode 994. 腐烂的橘子`
  - `LeetCode 542. 01矩阵（多源BFS）`

### 📌 **3. 层级问题（需要分层）**
- 经典如树的层序遍历
- 示例题：
  - `LeetCode 102. 二叉树的层序遍历`

### 📌 **4. 状态转移模型（像走迷宫）**
- 迷宫问题、棋盘问题
- 例如走迷宫，BFS更快找到出路

---

## ✅ 三、总结对比（口诀）：
| 场景                    | 推荐方法 | 理由 |
|------------------------|--------|-----|
| 求最短路径              | BFS    | 先到即最短 |
| 求所有解/路径搜索         | DFS    | 深入找全解 |
| 树结构问题                | DFS/BFS都可 | DFS更直观，BFS用于层次|
| 连通区域统计              | DFS    | 递归方便 |
| 多源蔓延、感染模拟         | BFS    | 自然扩散，层层推进 |
| 空间受限（不允许queue太大） | DFS    | queue容易炸 |

---

## ✅ 四、面试建议：
- 只要听到“最短”、“最小步数”，下意识想 **BFS**
- 只要听到“全部路径”、“组合”、“递归” 下意识想 **DFS / 回溯**
- 如果是树，DFS先想，层序遍历时才考虑BFS

---

## 📌 五、举个经典对比例子：
**题目：`LeetCode 200. 岛屿数量`**
- 用 DFS：直接递归，找到1就沉没它（标0）
- 用 BFS：用队列，从1扩散出去，把相连的1全变0
- 两种都行，DFS写起来更简单，BFS适合面试时展示思路清晰和控制递归深度




# 思路

✅ **完全正确！你抓住了这类递归/DFS算法的核心思路。**

在写 `findTargetSumWays` 或者类似**递归搜索题目**时，脑子里一定要有这种思考框架：

---

## 📌 **1. 明确“递归的终点”（走到底的标志）**
- 所谓“走到底”，就是数组用完了：`if idx == len(nums)`
- **只有到这个时候**，你才真正完成了一条完整的路径（从根到叶）
- 这个时候唯一能做的事就是：**检查这条路径对不对**
```python
if idx == len(nums):
    return 1 if sums == target else 0
```

---

## 📌 **2. 每一层递归都做两件事：**
- **往左走（加法）**：`dfs(idx + 1, sums + nums[idx])`
- **往右走（减法）**：`dfs(idx + 1, sums - nums[idx])`
- 自然形成了一棵二叉树，下一步只有两种可能

---

## 📌 **3. 回来之后怎么处理？**
- 子树走到底回来的是“满足条件的方案数”
- 当前这层递归，直接把左右子树的方案数加起来，返回给上层

```python
left = dfs(idx + 1, sums + nums[idx])
right = dfs(idx + 1, sums - nums[idx])
return left + right
```

---

## ✅ **4. 公式化你的思考：**
> 每一层：  
> `总方案数 = 左边能走出的方案数 + 右边能走出的方案数`

✅ 你写代码时，目标清晰：
- **先走到底**
- **在底部判断是不是答案**
- **答案传回来，累计即可**

---

## 📌 **5. 这样写出来的代码，结构特别清晰、通用性强：**
```python
def dfs(idx, sums):
    if idx == len(nums):
        return 1 if sums == target else 0
    return dfs(idx + 1, sums + nums[idx]) + dfs(idx + 1, sums - nums[idx])
```

---

## ✅ **总结（递归框架心法）**：
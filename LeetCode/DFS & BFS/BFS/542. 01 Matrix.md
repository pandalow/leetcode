Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.

The distance between two cells sharing a common edge is 1.

 

Example 1:


Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Example 2:


Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
 

Constraints:

m == mat.length
n == mat[i].length
1 <= m, n <= 104
1 <= m * n <= 104
mat[i][j] is either 0 or 1.
There is at least one 0 in mat.

ä¸‹é¢è¿™ä¸ªç­”æ¡ˆ time limit exceeded

```python
class Solution(object):
    def updateMatrix(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: List[List[int]]
        """
        m = len(mat)
        n = len(mat[0])

        directions = [(1,0),(-1,0),(0,1),(0,-1)]

        def bfs(i, j):
            count = 0
            visited = set()
            queue = collections.deque()

            visited.add((i,j))
            queue.append((i,j))

            while queue:
                size = len(queue)
                for _ in range(size):
                    di, dj = queue.popleft()
                    if mat[di][dj] == 0:
                        return count
                    for dx, dy in directions:
                        nx, ny= di+dx,dj+dy
                        if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:
                            visited.add((nx,ny))
                            queue.append((nx,ny))
                count+=1
        
        ans = []
        for i in range(m):
            ans.append([bfs(i,j) for j in range(n)])
        
        return ans
            
```


æ›´ä¼˜ç§€çš„è§£æ³•, è¿˜ä¸æ˜¯ç‰¹åˆ«æ˜ç™½
å½“ç„¶å¯ä»¥ï¼ğŸ¯ **è¿™æ˜¯æ›´å¿«çš„è§£å†³æ–¹æ³•ï¼šå¤šæº BFSï¼ˆMulti-Source BFSï¼‰**

---

## âœ… æ ¸å¿ƒæ€æƒ³

> ä¸å…¶ä»æ¯ä¸ª `1` å‡ºå‘æ‰¾ç¦»å®ƒæœ€è¿‘çš„ `0`ï¼Œä¸å¦‚åè¿‡æ¥ï¼š  
> **ä»æ‰€æœ‰çš„ `0` ä¸€èµ·å‡ºå‘ï¼ŒåŒæ—¶æ‰©æ•£ï¼ŒæŠŠç¦»å®ƒæœ€è¿‘çš„æ‰€æœ‰ `1` æ ‡è®°ä¸Šè·ç¦»ã€‚**

å°±åƒæ¹–é¢ä¸ŠåŒæ—¶ä¸¢äº†å¾ˆå¤šçŸ³å¤´ï¼Œæ³¢çº¹ä¸€èµ·æ‰©æ•£ï¼Œæœ€å…ˆæ‰©æ•£åˆ°çš„ä½ç½®å°±æ˜¯æœ€è¿‘çš„ã€‚

---

## ğŸ’¡ è¿™æ ·æœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿ

| æ–¹æ³•        | æ—¶é—´å¤æ‚åº¦ |
|-------------|------------|
| å•ç‚¹ BFS    | O((mn)^2)  |
| å¤šæº BFS âœ… | O(mn)      |

---

## âœ… å¤šæº BFS åŠ é€Ÿç‰ˆä»£ç 

```python
import collections

class Solution(object):
    def updateMatrix(self, mat):
        m, n = len(mat), len(mat[0])
        directions = [(1,0), (-1,0), (0,1), (0,-1)]

        # åˆå§‹åŒ–ç»“æœçŸ©é˜µ
        dist = [[-1] * n for _ in range(m)]

        # åˆå§‹åŒ–é˜Ÿåˆ—ï¼šæŠŠæ‰€æœ‰ 0 å…¥é˜Ÿ
        queue = collections.deque()
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    dist[i][j] = 0
                    queue.append((i, j))

        # å¤šæº BFS
        while queue:
            x, y = queue.popleft()
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and dist[nx][ny] == -1:
                    dist[nx][ny] = dist[x][y] + 1
                    queue.append((nx, ny))

        return dist
```

---

## ğŸ“ˆ è¾“å…¥è¾“å‡ºç¤ºä¾‹

**è¾“å…¥ï¼š**
```python
mat = [
  [0, 0, 0],
  [0, 1, 0],
  [1, 1, 1]
]
```

**è¾“å‡ºï¼š**
```python
[
  [0, 0, 0],
  [0, 1, 0],
  [1, 2, 1]
]
```

---

## ğŸ” å°æŠ€å·§è§£é‡Š

| æ­¥éª¤ | è¯´æ˜ |
|------|------|
| `dist[i][j] = 0` | åˆå§‹åŒ– 0 çš„ä½ç½®ï¼Œè¡¨ç¤ºå®ƒä»¬ç¦»æœ€è¿‘çš„ 0 æ˜¯ 0 |
| `dist == -1` | è¡¨ç¤ºè¿™ä¸ªæ ¼å­è¿˜æ²¡æ›´æ–°ï¼Œé¿å…é‡å¤å…¥é˜Ÿ |
| `dist[nx][ny] = dist[x][y] + 1` | æ‰©æ•£é€»è¾‘ï¼Œå½“å‰è·ç¦» +1 |
| `queue.append()` | ç±»ä¼¼äºæ³¢çº¹å¾€å¤–æ‰© |

---

## âœ… æ€»ç»“

| æ–¹æ³• | ç®€æ´ | é«˜æ•ˆ | æ¨èä½¿ç”¨ |
|------|------|------|----------|
| å•ç‚¹ BFS | âŒ æ…¢ | âŒ | âŒ |
| å¤šæº BFS | âœ… å¿« | âœ… | âœ…âœ…âœ… |

---

å¦‚æœä½ éœ€è¦è¿™ä¸ªä»£ç çš„å›¾ç¤ºæ¼”ç¤ºæˆ–è€…å†™æ³•å¯¹æ¯”ï¼Œæˆ–è€…è½¬æ¢æˆ C++ / Java / Python3ï¼Œä¹Ÿå¯ä»¥å‘Šè¯‰æˆ‘ï½æˆ‘æ¥å¸®ä½ æ‹“å±•ï½ğŸ˜Š